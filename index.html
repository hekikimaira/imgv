<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ImageDeck v2</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

  :root {
    --bg-primary: #0a0a0c;
    --bg-secondary: #111115;
    --bg-tertiary: #18181d;
    --bg-hover: #1f1f26;
    --bg-active: #252530;
    --border: #2a2a35;
    --text-primary: #e8e8ed;
    --text-secondary: #8888a0;
    --text-muted: #555568;
    --accent: #6c8aff;
    --accent-dim: #4a62c0;
    --accent-bg: rgba(108,138,255,0.08);
    --danger: #ff6b6b;
    --success: #5ce0a0;
    --sidebar-width: 280px;
    --toolbar-height: 48px;
    --radius: 8px;
    --radius-sm: 5px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body {
    font-family: 'DM Sans', -apple-system, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    height: 100dvh;
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
  }

  .app { display: flex; height: 100dvh; }

  /* ===== SIDEBAR ===== */
  .sidebar {
    width: var(--sidebar-width);
    min-width: var(--sidebar-width);
    background: var(--bg-secondary);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    z-index: 10;
  }

  .sidebar-header {
    padding: 16px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .sidebar-header h1 { font-size: 15px; font-weight: 700; letter-spacing: -0.02em; }
  .sidebar-header h1 span { color: var(--accent); }

  .icon-btn {
    width: 34px; height: 34px; border: none; background: transparent;
    color: var(--text-secondary); border-radius: var(--radius-sm);
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 18px; transition: all 0.15s;
  }
  .icon-btn:hover, .icon-btn:active { background: var(--bg-hover); color: var(--text-primary); }

  .folder-list { flex: 1; overflow-y: auto; padding: 8px; -webkit-overflow-scrolling: touch; }

  .folder-item {
    display: flex; align-items: center; padding: 10px 12px;
    border-radius: var(--radius-sm); cursor: pointer;
    transition: all 0.12s; gap: 10px;
  }
  .folder-item:active, .folder-item:hover { background: var(--bg-hover); }
  .folder-item.active { background: var(--accent-bg); color: var(--accent); }

  .folder-icon { font-size: 18px; color: var(--text-muted); flex-shrink: 0; width: 22px; text-align: center; }
  .folder-item.active .folder-icon { color: var(--accent); }

  .folder-name { font-size: 13px; font-weight: 500; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

  .folder-count {
    font-size: 11px; font-family: 'JetBrains Mono', monospace;
    color: var(--text-muted); background: var(--bg-tertiary);
    padding: 2px 7px; border-radius: 10px; min-width: 22px; text-align: center;
  }
  .folder-item.active .folder-count { background: rgba(108,138,255,0.15); color: var(--accent-dim); }

  .folder-divider { height: 1px; background: var(--border); margin: 8px 12px; }
  .drop-target { outline: 2px dashed var(--accent); outline-offset: -2px; background: var(--accent-bg) !important; }

  /* ===== MAIN ===== */
  .main { flex: 1; display: flex; flex-direction: column; min-width: 0; }

  .toolbar {
    height: var(--toolbar-height); background: var(--bg-secondary);
    border-bottom: 1px solid var(--border); display: flex;
    align-items: center; padding: 0 12px; gap: 8px; flex-shrink: 0;
  }

  .toolbar-left { display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0; }
  .toolbar-right { display: flex; align-items: center; gap: 4px; }

  .current-folder-name { font-size: 14px; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

  .file-count-badge { font-size: 11px; font-family: 'JetBrains Mono', monospace; color: var(--text-muted); flex-shrink: 0; }

  .size-switch {
    display: flex; background: var(--bg-tertiary); border-radius: var(--radius-sm);
    overflow: hidden; border: 1px solid var(--border);
  }

  .size-btn {
    padding: 6px 10px; border: none; background: transparent;
    color: var(--text-muted); font-size: 12px;
    font-family: 'JetBrains Mono', monospace; cursor: pointer; transition: all 0.15s;
  }
  .size-btn.active { background: var(--accent); color: #fff; }

  .import-btn {
    padding: 6px 14px; border: 1px solid var(--accent-dim); background: transparent;
    color: var(--accent); font-size: 12px; font-weight: 600;
    font-family: 'DM Sans', sans-serif; border-radius: var(--radius-sm);
    cursor: pointer; transition: all 0.15s;
  }
  .import-btn:active { background: var(--accent); color: #fff; }

  /* ===== VIRTUAL GRID ===== */
  .grid-container {
    flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch;
    position: relative;
  }

  .grid-viewport { position: relative; width: 100%; }

  .grid-row {
    position: absolute; left: 0; right: 0;
    display: flex; gap: 6px; padding: 0 12px;
  }

  .grid-cell {
    position: relative; border-radius: var(--radius-sm);
    overflow: hidden; cursor: pointer; background: var(--bg-tertiary);
    flex-shrink: 0; transition: transform 0.12s;
  }
  .grid-cell:active { transform: scale(0.96); }
  .grid-cell.selected { outline: 3px solid var(--accent); outline-offset: -3px; }

  .grid-cell img { width: 100%; height: 100%; object-fit: cover; display: block; pointer-events: none; }

  .cell-check {
    position: absolute; top: 5px; left: 5px; width: 22px; height: 22px;
    border-radius: 50%; border: 2px solid rgba(255,255,255,0.5);
    background: rgba(0,0,0,0.3); display: none;
    align-items: center; justify-content: center; color: #fff; font-size: 13px;
  }
  .select-mode .cell-check { display: flex; }
  .grid-cell.selected .cell-check { background: var(--accent); border-color: var(--accent); }

  /* ===== PROGRESS ===== */
  .progress-bar {
    position: fixed; top: 0; left: 0; right: 0; height: 3px;
    z-index: 50; display: none;
  }
  .progress-bar.active { display: block; }
  .progress-fill {
    height: 100%; background: var(--accent);
    transition: width 0.2s; width: 0%;
  }

  .import-status {
    position: fixed; bottom: max(20px, env(safe-area-inset-bottom));
    left: 50%; transform: translateX(-50%);
    background: var(--bg-tertiary); border: 1px solid var(--border);
    padding: 10px 20px; border-radius: 24px; font-size: 13px;
    font-weight: 500; z-index: 300; display: none; white-space: nowrap;
  }
  .import-status.active { display: block; }

  /* ===== EMPTY ===== */
  .empty-state {
    display: flex; flex-direction: column; align-items: center;
    justify-content: center; height: 100%; color: var(--text-muted);
    gap: 12px; padding: 40px; text-align: center;
  }
  .empty-state .empty-icon { font-size: 48px; opacity: 0.4; }
  .empty-state p { font-size: 14px; line-height: 1.6; }
  .empty-state .hint { font-size: 12px; opacity: 0.6; }

  /* ===== VIEWER ===== */
  .viewer {
    position: fixed; inset: 0; background: #000; z-index: 100;
    display: none; align-items: center; justify-content: center;
    touch-action: none;
  }
  .viewer.active { display: flex; }

  .viewer img {
    max-width: 100%; max-height: 100%; object-fit: contain;
    pointer-events: none; transition: transform 0.15s ease-out, opacity 0.15s;
  }

  .viewer-info {
    position: absolute; bottom: 0; left: 0; right: 0;
    padding: 16px 20px; padding-bottom: max(16px, env(safe-area-inset-bottom));
    background: linear-gradient(transparent, rgba(0,0,0,0.6));
    display: flex; justify-content: space-between; align-items: flex-end;
    pointer-events: none; opacity: 0; transition: opacity 0.3s;
  }
  .viewer.show-info .viewer-info { opacity: 1; }
  .viewer-filename { font-size: 13px; color: rgba(255,255,255,0.8); }
  .viewer-counter { font-size: 12px; font-family: 'JetBrains Mono', monospace; color: rgba(255,255,255,0.5); }

  /* ===== SELECT BAR ===== */
  .select-bar {
    height: var(--toolbar-height); background: var(--accent);
    display: none; align-items: center; padding: 0 12px; gap: 12px; flex-shrink: 0;
  }
  .select-bar.active { display: flex; }
  .select-bar.active + .toolbar { display: none; }
  .select-bar .select-count { font-size: 14px; font-weight: 600; color: #fff; flex: 1; }
  .select-bar button {
    padding: 6px 14px; border: 1px solid rgba(255,255,255,0.3);
    background: transparent; color: #fff; font-size: 12px; font-weight: 600;
    font-family: 'DM Sans', sans-serif; border-radius: var(--radius-sm); cursor: pointer;
  }
  .select-bar button:active { background: rgba(255,255,255,0.2); }

  /* ===== MODAL ===== */
  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    z-index: 200; display: none; align-items: center;
    justify-content: center; padding: 20px;
  }
  .modal-overlay.active { display: flex; }

  .modal {
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 14px; width: 100%; max-width: 340px; overflow: hidden;
  }
  .modal-header { padding: 18px 20px 12px; font-size: 16px; font-weight: 600; }
  .modal-body { padding: 0 20px 18px; }

  .modal-input {
    width: 100%; padding: 10px 14px; background: var(--bg-tertiary);
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    color: var(--text-primary); font-size: 14px;
    font-family: 'DM Sans', sans-serif; outline: none;
  }
  .modal-input:focus { border-color: var(--accent); }

  .modal-footer { display: flex; border-top: 1px solid var(--border); }

  .modal-btn {
    flex: 1; padding: 14px; border: none; background: transparent;
    color: var(--text-secondary); font-size: 15px; font-weight: 500;
    font-family: 'DM Sans', sans-serif; cursor: pointer;
  }
  .modal-btn:active { background: var(--bg-hover); }
  .modal-btn.primary { color: var(--accent); font-weight: 600; }
  .modal-btn.danger { color: var(--danger); }
  .modal-btn + .modal-btn { border-left: 1px solid var(--border); }

  .move-folder-list { max-height: 240px; overflow-y: auto; margin-top: 8px; }
  .move-folder-item {
    display: flex; align-items: center; gap: 10px; padding: 10px 12px;
    border-radius: var(--radius-sm); cursor: pointer; font-size: 14px;
  }
  .move-folder-item:active { background: var(--bg-hover); }

  /* ===== CONTEXT MENU ===== */
  .context-menu {
    position: fixed; background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 12px; padding: 6px; z-index: 150; display: none;
    min-width: 180px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  }
  .context-menu.active { display: block; }
  .ctx-item {
    display: flex; align-items: center; gap: 10px; padding: 10px 14px;
    border-radius: var(--radius-sm); font-size: 14px; cursor: pointer;
  }
  .ctx-item:active { background: var(--bg-hover); }
  .ctx-item.danger { color: var(--danger); }
  .ctx-divider { height: 1px; background: var(--border); margin: 4px 8px; }

  /* ===== TOAST ===== */
  .toast {
    position: fixed; bottom: max(20px, env(safe-area-inset-bottom));
    left: 50%; transform: translateX(-50%) translateY(100px);
    background: var(--bg-tertiary); border: 1px solid var(--border);
    color: var(--text-primary); padding: 10px 20px; border-radius: 24px;
    font-size: 13px; font-weight: 500; z-index: 300;
    transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
    pointer-events: none; white-space: nowrap;
  }
  .toast.show { transform: translateX(-50%) translateY(0); }

  .drop-zone-overlay {
    position: fixed; inset: 0; background: rgba(108,138,255,0.08);
    border: 3px dashed var(--accent); z-index: 50; display: none;
    align-items: center; justify-content: center; pointer-events: none;
  }
  .drop-zone-overlay.active { display: flex; }
  .drop-zone-overlay span { font-size: 18px; font-weight: 600; color: var(--accent); }

  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
</style>
</head>
<body>

<div class="app">
  <aside class="sidebar">
    <div class="sidebar-header">
      <h1>Image<span>Deck</span></h1>
      <button class="icon-btn" onclick="showNewFolderModal()" title="新規フォルダ">＋</button>
    </div>
    <div class="folder-list" id="folderList"></div>
  </aside>

  <div class="main">
    <div class="select-bar" id="selectBar">
      <button onclick="exitSelectMode()">✕</button>
      <span class="select-count" id="selectCount">0件選択</span>
      <button onclick="showMoveModal()">移動</button>
      <button onclick="deleteSelected()">削除</button>
    </div>
    <div class="toolbar" id="toolbar">
      <div class="toolbar-left">
        <span class="current-folder-name" id="currentFolderName">すべて</span>
        <span class="file-count-badge" id="fileCount"></span>
      </div>
      <div class="toolbar-right">
        <div class="size-switch">
          <button class="size-btn" data-size="S" onclick="setGridSize('S')">S</button>
          <button class="size-btn active" data-size="M" onclick="setGridSize('M')">M</button>
          <button class="size-btn" data-size="L" onclick="setGridSize('L')">L</button>
        </div>
        <label class="import-btn" for="fileInput">＋追加</label>
        <input type="file" id="fileInput" accept="image/*" multiple style="display:none" onchange="handleFileImport(event)">
      </div>
    </div>
    <div class="grid-container" id="gridContainer">
      <div class="grid-viewport" id="gridViewport"></div>
    </div>
  </div>
</div>

<!-- VIEWER -->
<div class="viewer" id="viewer">
  <img id="viewerImg" src="" alt="">
  <div class="viewer-info">
    <span class="viewer-filename" id="viewerFilename"></span>
    <span class="viewer-counter" id="viewerCounter"></span>
  </div>
</div>

<!-- MODALS -->
<div class="modal-overlay" id="newFolderModal">
  <div class="modal">
    <div class="modal-header">新規フォルダ</div>
    <div class="modal-body"><input class="modal-input" id="newFolderInput" placeholder="フォルダ名" autocomplete="off"></div>
    <div class="modal-footer">
      <button class="modal-btn" onclick="closeModal('newFolderModal')">キャンセル</button>
      <button class="modal-btn primary" onclick="createFolder()">作成</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="renameFolderModal">
  <div class="modal">
    <div class="modal-header">フォルダ名変更</div>
    <div class="modal-body"><input class="modal-input" id="renameFolderInput" placeholder="新しいフォルダ名" autocomplete="off"></div>
    <div class="modal-footer">
      <button class="modal-btn" onclick="closeModal('renameFolderModal')">キャンセル</button>
      <button class="modal-btn primary" onclick="renameFolder()">変更</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="moveFolderModal">
  <div class="modal">
    <div class="modal-header">移動先を選択</div>
    <div class="modal-body"><div class="move-folder-list" id="moveFolderList"></div></div>
    <div class="modal-footer"><button class="modal-btn" onclick="closeModal('moveFolderModal')">キャンセル</button></div>
  </div>
</div>

<div class="context-menu" id="contextMenu"></div>
<div class="drop-zone-overlay" id="dropOverlay"><span>ここにドロップ</span></div>
<div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
<div class="import-status" id="importStatus"></div>
<div class="toast" id="toast"></div>

<script>
// ===== DB =====
const DB_NAME = 'ImageDeckDB2';
const DB_VERSION = 2;
let db;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('meta')) {
        const ms = d.createObjectStore('meta', { keyPath: 'id' });
        ms.createIndex('folderId', 'folderId', { unique: false });
        ms.createIndex('addedAt', 'addedAt', { unique: false });
      }
      if (!d.objectStoreNames.contains('thumbs')) {
        d.createObjectStore('thumbs', { keyPath: 'id' });
      }
      if (!d.objectStoreNames.contains('images')) {
        d.createObjectStore('images', { keyPath: 'id' });
      }
      if (!d.objectStoreNames.contains('folders')) {
        d.createObjectStore('folders', { keyPath: 'id' });
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e);
  });
}

function dbTx(stores, mode = 'readonly') {
  const tx = db.transaction(stores, mode);
  if (Array.isArray(stores)) {
    return stores.map(s => tx.objectStore(s));
  }
  return tx.objectStore(stores);
}

function dbReq(req) {
  return new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function dbAll(store) { return dbReq(dbTx(store).getAll()); }
function dbGet(store, key) { return dbReq(dbTx(store).get(key)); }
function dbPut(store, data) { return dbReq(dbTx(store, 'readwrite').put(data)); }
function dbDel(store, key) { return dbReq(dbTx(store, 'readwrite').delete(key)); }

function dbGetByIndex(store, idx, val) {
  return dbReq(dbTx(store).index(idx).getAll(val));
}

// Batch put for performance
function dbBatchPut(operations) {
  return new Promise((resolve, reject) => {
    const storeNames = [...new Set(operations.map(o => o.store))];
    const tx = db.transaction(storeNames, 'readwrite');
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
    for (const op of operations) {
      tx.objectStore(op.store).put(op.data);
    }
  });
}

function dbBatchDel(store, keys) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
    const s = tx.objectStore(store);
    for (const k of keys) s.delete(k);
  });
}

// ===== STATE =====
let folders = [];
let currentFolderId = '__all__';
let metaList = [];        // current folder's image metadata (lightweight)
let selectedIds = new Set();
let selectMode = false;
let gridSize = 'M';
let contextFolderId = null;

// Virtual scroll state
let colCount = 4;
let cellSize = 130;
const GAP = 6;
const PAD = 12;
let visibleRows = {};
let scrollRAF = null;

// Viewer
let viewerIndex = -1;
let swipeUpCount = 0, swipeUpTimer = null;

// ===== GRID SIZE CONFIG =====
const SIZE_CONFIG = { S: 80, M: 130, L: 200 };

// ===== INIT =====
async function init() {
  await openDB();
  await loadFolders();
  await loadMeta();
  setupScroll();
  setupDragDrop();
  window.addEventListener('resize', () => { computeGrid(); renderVirtual(); });
}

// ===== FOLDERS =====
async function loadFolders() {
  folders = await dbAll('folders');
  folders.sort((a, b) => a.createdAt - b.createdAt);
  await renderFolders();
}

async function renderFolders() {
  const allMeta = await dbAll('meta');
  const countMap = {};
  let total = allMeta.length;
  let unsorted = 0;
  allMeta.forEach(m => {
    if (!m.folderId || m.folderId === '__unsorted__') unsorted++;
    else countMap[m.folderId] = (countMap[m.folderId] || 0) + 1;
  });

  const list = document.getElementById('folderList');
  let html = `
    <div class="folder-item ${currentFolderId === '__all__' ? 'active' : ''}"
         onclick="selectFolder('__all__')" data-folder-id="__all__">
      <span class="folder-icon">◻</span><span class="folder-name">すべて</span>
      <span class="folder-count">${total}</span>
    </div>
    <div class="folder-item ${currentFolderId === '__unsorted__' ? 'active' : ''}"
         onclick="selectFolder('__unsorted__')" data-folder-id="__unsorted__">
      <span class="folder-icon">○</span><span class="folder-name">未分類</span>
      <span class="folder-count">${unsorted}</span>
    </div>`;

  if (folders.length > 0) html += '<div class="folder-divider"></div>';

  folders.forEach(f => {
    html += `<div class="folder-item ${currentFolderId === f.id ? 'active' : ''}"
                  onclick="selectFolder('${f.id}')" data-folder-id="${f.id}">
      <span class="folder-icon">■</span>
      <span class="folder-name">${esc(f.name)}</span>
      <span class="folder-count">${countMap[f.id] || 0}</span>
    </div>`;
  });

  list.innerHTML = html;
  setupFolderLongPress();
}

function setupFolderLongPress() {
  document.querySelectorAll('.folder-item').forEach(el => {
    const fid = el.dataset.folderId;
    if (fid === '__all__' || fid === '__unsorted__') return;
    let timer;
    el.addEventListener('touchstart', e => {
      timer = setTimeout(() => { e.preventDefault(); showFolderCtx(fid, e.touches[0].clientX, e.touches[0].clientY); }, 500);
    }, { passive: false });
    el.addEventListener('touchend', () => clearTimeout(timer));
    el.addEventListener('touchmove', () => clearTimeout(timer));
    el.addEventListener('contextmenu', e => { e.preventDefault(); showFolderCtx(fid, e.clientX, e.clientY); });
  });
}

function showFolderCtx(fid, x, y) {
  contextFolderId = fid;
  const menu = document.getElementById('contextMenu');
  menu.innerHTML = `
    <div class="ctx-item" onclick="startRenameFolder()"><span style="width:20px;text-align:center">✎</span>名前を変更</div>
    <div class="ctx-divider"></div>
    <div class="ctx-item danger" onclick="confirmDeleteFolder()"><span style="width:20px;text-align:center">✕</span>フォルダを削除</div>`;
  menu.style.left = Math.min(x, innerWidth - 200) + 'px';
  menu.style.top = Math.min(y, innerHeight - 120) + 'px';
  menu.classList.add('active');
  setTimeout(() => document.addEventListener('pointerdown', () => menu.classList.remove('active'), { once: true }), 10);
}

function showNewFolderModal() {
  document.getElementById('newFolderInput').value = '';
  document.getElementById('newFolderModal').classList.add('active');
  setTimeout(() => document.getElementById('newFolderInput').focus(), 100);
}

async function createFolder() {
  const name = document.getElementById('newFolderInput').value.trim();
  if (!name) return;
  await dbPut('folders', { id: 'f_' + Date.now(), name, createdAt: Date.now() });
  closeModal('newFolderModal');
  await loadFolders();
  toast(`「${name}」を作成`);
}

function startRenameFolder() {
  document.getElementById('contextMenu').classList.remove('active');
  const f = folders.find(f => f.id === contextFolderId);
  if (!f) return;
  document.getElementById('renameFolderInput').value = f.name;
  document.getElementById('renameFolderModal').classList.add('active');
  setTimeout(() => document.getElementById('renameFolderInput').focus(), 100);
}

async function renameFolder() {
  const name = document.getElementById('renameFolderInput').value.trim();
  if (!name) return;
  const f = folders.find(f => f.id === contextFolderId);
  if (!f) return;
  f.name = name;
  await dbPut('folders', f);
  closeModal('renameFolderModal');
  await loadFolders();
  if (currentFolderId === contextFolderId) document.getElementById('currentFolderName').textContent = name;
  toast('名前を変更しました');
}

async function confirmDeleteFolder() {
  document.getElementById('contextMenu').classList.remove('active');
  const f = folders.find(f => f.id === contextFolderId);
  if (!f) return;
  if (!confirm(`「${f.name}」を削除しますか？\n中の画像は未分類に移動します。`)) return;
  const imgs = await dbGetByIndex('meta', 'folderId', contextFolderId);
  for (const m of imgs) { m.folderId = '__unsorted__'; await dbPut('meta', m); }
  await dbDel('folders', contextFolderId);
  if (currentFolderId === contextFolderId) currentFolderId = '__all__';
  await loadFolders();
  await loadMeta();
  toast('フォルダを削除しました');
}

async function selectFolder(fid) {
  currentFolderId = fid;
  exitSelectMode();
  await renderFolders();
  await loadMeta();
}

// ===== META (lightweight index) =====
async function loadMeta() {
  let list;
  if (currentFolderId === '__all__') {
    list = await dbAll('meta');
  } else if (currentFolderId === '__unsorted__') {
    const all = await dbAll('meta');
    list = all.filter(m => !m.folderId || m.folderId === '__unsorted__');
  } else {
    list = await dbGetByIndex('meta', 'folderId', currentFolderId);
  }
  list.sort((a, b) => b.addedAt - a.addedAt);
  metaList = list;
  computeGrid();
  renderVirtual();
  updateToolbar();
}

function updateToolbar() {
  const name = currentFolderId === '__all__' ? 'すべて' :
               currentFolderId === '__unsorted__' ? '未分類' :
               (folders.find(f => f.id === currentFolderId)?.name || '');
  document.getElementById('currentFolderName').textContent = name;
  document.getElementById('fileCount').textContent = metaList.length > 0 ? `${metaList.length}枚` : '';
}

// ===== VIRTUAL SCROLL =====
function computeGrid() {
  const container = document.getElementById('gridContainer');
  const w = container.clientWidth - PAD * 2;
  cellSize = SIZE_CONFIG[gridSize];
  colCount = Math.max(1, Math.floor((w + GAP) / (cellSize + GAP)));
  const rowCount = Math.ceil(metaList.length / colCount);
  const totalH = rowCount * (cellSize + GAP) + PAD * 2;
  document.getElementById('gridViewport').style.height = totalH + 'px';
}

function setupScroll() {
  const container = document.getElementById('gridContainer');
  container.addEventListener('scroll', () => {
    if (!scrollRAF) scrollRAF = requestAnimationFrame(() => { renderVirtual(); scrollRAF = null; });
  }, { passive: true });
}

function renderVirtual() {
  const container = document.getElementById('gridContainer');
  const viewport = document.getElementById('gridViewport');

  if (metaList.length === 0) {
    viewport.innerHTML = `<div class="empty-state">
      <div class="empty-icon">◇</div><p>画像がありません</p>
      <p class="hint">「＋追加」ボタンかドラッグ＆ドロップで<br>画像を追加してください</p>
    </div>`;
    return;
  }

  const scrollTop = container.scrollTop;
  const viewH = container.clientHeight;
  const rowH = cellSize + GAP;

  const firstRow = Math.max(0, Math.floor((scrollTop - PAD) / rowH) - 2);
  const lastRow = Math.min(
    Math.ceil(metaList.length / colCount) - 1,
    Math.ceil((scrollTop + viewH - PAD) / rowH) + 2
  );

  // Remove out-of-range rows
  const newVisible = {};
  for (let r = firstRow; r <= lastRow; r++) newVisible[r] = true;

  Object.keys(visibleRows).forEach(r => {
    if (!newVisible[r]) {
      visibleRows[r].remove();
      delete visibleRows[r];
    }
  });

  // Add new rows
  for (let r = firstRow; r <= lastRow; r++) {
    if (visibleRows[r]) continue;

    const rowEl = document.createElement('div');
    rowEl.className = 'grid-row';
    if (selectMode) rowEl.classList.add('select-mode');
    rowEl.style.top = (PAD + r * rowH) + 'px';
    rowEl.style.height = cellSize + 'px';

    const startIdx = r * colCount;
    const endIdx = Math.min(startIdx + colCount, metaList.length);

    for (let i = startIdx; i < endIdx; i++) {
      const m = metaList[i];
      const cell = document.createElement('div');
      cell.className = 'grid-cell' + (selectedIds.has(m.id) ? ' selected' : '');
      cell.style.width = cellSize + 'px';
      cell.style.height = cellSize + 'px';
      cell.dataset.id = m.id;
      cell.dataset.index = i;

      // Lazy load thumbnail
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.alt = '';
      cell.appendChild(img);
      loadThumb(m.id, img);

      const chk = document.createElement('div');
      chk.className = 'cell-check';
      chk.textContent = selectedIds.has(m.id) ? '✓' : '';
      cell.appendChild(chk);

      // Click
      cell.addEventListener('click', () => {
        if (selectMode) toggleSelect(m.id);
        else openViewer(i);
      });

      // Long press
      let lt;
      cell.addEventListener('touchstart', e => {
        lt = setTimeout(() => {
          if (!selectMode) enterSelectMode();
          toggleSelect(m.id);
        }, 400);
      }, { passive: true });
      cell.addEventListener('touchend', () => clearTimeout(lt));
      cell.addEventListener('touchmove', () => clearTimeout(lt));

      rowEl.appendChild(cell);
    }

    viewport.appendChild(rowEl);
    visibleRows[r] = rowEl;
  }
}

// Thumb cache in memory
const thumbCache = new Map();
const THUMB_CACHE_MAX = 2000;

async function loadThumb(id, imgEl) {
  if (thumbCache.has(id)) {
    imgEl.src = thumbCache.get(id);
    return;
  }
  try {
    const t = await dbGet('thumbs', id);
    if (t && t.data) {
      if (thumbCache.size > THUMB_CACHE_MAX) {
        const first = thumbCache.keys().next().value;
        thumbCache.delete(first);
      }
      thumbCache.set(id, t.data);
      imgEl.src = t.data;
    }
  } catch(e) {}
}

// ===== SELECT MODE =====
function enterSelectMode() {
  selectMode = true;
  selectedIds.clear();
  document.getElementById('selectBar').classList.add('active');
  updateSelectCount();
  // Re-render to add select-mode class
  Object.values(visibleRows).forEach(r => r.classList.add('select-mode'));
}

function exitSelectMode() {
  selectMode = false;
  selectedIds.clear();
  document.getElementById('selectBar').classList.remove('active');
  clearVisibleRows();
  renderVirtual();
}

function toggleSelect(id) {
  if (selectedIds.has(id)) selectedIds.delete(id); else selectedIds.add(id);
  updateSelectCount();
  // Update cells
  document.querySelectorAll('.grid-cell').forEach(c => {
    const sel = selectedIds.has(c.dataset.id);
    c.classList.toggle('selected', sel);
    const chk = c.querySelector('.cell-check');
    if (chk) chk.textContent = sel ? '✓' : '';
  });
}

function updateSelectCount() {
  document.getElementById('selectCount').textContent = `${selectedIds.size}件選択`;
}

async function deleteSelected() {
  if (selectedIds.size === 0) return;
  if (!confirm(`${selectedIds.size}件の画像を削除しますか？`)) return;
  const ids = [...selectedIds];
  await dbBatchDel('meta', ids);
  await dbBatchDel('thumbs', ids);
  await dbBatchDel('images', ids);
  ids.forEach(id => thumbCache.delete(id));
  toast(`${ids.length}件削除しました`);
  exitSelectMode();
  await loadFolders();
  await loadMeta();
}

function showMoveModal() {
  if (selectedIds.size === 0) return;
  const list = document.getElementById('moveFolderList');
  let html = `<div class="move-folder-item" onclick="moveSelectedTo('__unsorted__')">
    <span style="font-size:18px">○</span>未分類</div>`;
  folders.forEach(f => {
    html += `<div class="move-folder-item" onclick="moveSelectedTo('${f.id}')">
      <span style="font-size:18px">■</span>${esc(f.name)}</div>`;
  });
  list.innerHTML = html;
  document.getElementById('moveFolderModal').classList.add('active');
}

async function moveSelectedTo(fid) {
  for (const id of selectedIds) {
    const m = await dbGet('meta', id);
    if (m) { m.folderId = fid; await dbPut('meta', m); }
  }
  const fname = fid === '__unsorted__' ? '未分類' : (folders.find(f => f.id === fid)?.name || '');
  toast(`${selectedIds.size}件を「${fname}」に移動`);
  closeModal('moveFolderModal');
  exitSelectMode();
  await loadFolders();
  await loadMeta();
}

// ===== FILE IMPORT =====
async function handleFileImport(e) {
  const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
  if (!files.length) return;
  await importFiles(files);
  e.target.value = '';
}

async function importFiles(files) {
  const bar = document.getElementById('progressBar');
  const fill = document.getElementById('progressFill');
  const status = document.getElementById('importStatus');
  bar.classList.add('active');
  status.classList.add('active');

  const folderId = (currentFolderId === '__all__') ? '__unsorted__' : currentFolderId;
  let done = 0;

  for (const file of files) {
    status.textContent = `${done + 1} / ${files.length} 処理中...`;
    fill.style.width = ((done / files.length) * 100) + '%';

    try {
      const dataUrl = await readFile(file);
      const thumb = await resizeImage(dataUrl, 200, 0.7);
      const mid = await resizeImage(dataUrl, 800, 0.85);
      const id = 'i' + Date.now() + '_' + Math.random().toString(36).slice(2, 7);

      await dbBatchPut([
        { store: 'meta', data: { id, name: file.name, folderId, addedAt: Date.now(), size: file.size } },
        { store: 'thumbs', data: { id, data: thumb } },
        { store: 'images', data: { id, data: mid } }
      ]);
    } catch(e) {
      console.warn('Import failed:', file.name, e);
    }
    done++;
  }

  fill.style.width = '100%';
  status.textContent = `${done}枚を追加しました`;

  setTimeout(() => {
    bar.classList.remove('active');
    fill.style.width = '0%';
    status.classList.remove('active');
  }, 1500);

  thumbCache.clear();
  await loadFolders();
  await loadMeta();
  toast(`${done}枚を追加しました`);
}

function readFile(file) {
  return new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onload = () => resolve(r.result);
    r.onerror = () => reject(r.error);
    r.readAsDataURL(file);
  });
}

function resizeImage(dataUrl, maxPx, quality) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      let w = img.width, h = img.height;
      if (w > maxPx || h > maxPx) {
        if (w > h) { h = Math.round((maxPx * h) / w); w = maxPx; }
        else { w = Math.round((maxPx * w) / h); h = maxPx; }
      }
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      c.getContext('2d').drawImage(img, 0, 0, w, h);
      resolve(c.toDataURL('image/jpeg', quality));
    };
    img.onerror = () => resolve(dataUrl);
    img.src = dataUrl;
  });
}

// ===== DRAG & DROP =====
function setupDragDrop() {
  const overlay = document.getElementById('dropOverlay');
  document.addEventListener('dragenter', e => { e.preventDefault(); overlay.classList.add('active'); });
  document.addEventListener('dragover', e => {
    e.preventDefault();
    document.querySelectorAll('.folder-item').forEach(el => {
      const r = el.getBoundingClientRect();
      el.classList.toggle('drop-target',
        e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom);
    });
  });
  document.addEventListener('dragleave', e => {
    if (!e.relatedTarget || !document.contains(e.relatedTarget)) {
      overlay.classList.remove('active');
      document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
    }
  });
  document.addEventListener('drop', async e => {
    e.preventDefault();
    overlay.classList.remove('active');
    let tid = currentFolderId === '__all__' ? '__unsorted__' : currentFolderId;
    const dt = document.querySelector('.folder-item.drop-target');
    if (dt) { tid = dt.dataset.folderId; if (tid === '__all__') tid = '__unsorted__'; }
    document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
    if (files.length) {
      const origFolder = currentFolderId;
      currentFolderId = tid === '__unsorted__' ? tid : tid;
      await importFiles(files);
      currentFolderId = origFolder;
      await loadMeta();
    }
  });
}

// ===== VIEWER =====
function openViewer(index) {
  viewerIndex = index;
  showViewerImage();
  document.getElementById('viewer').classList.add('active');
  document.getElementById('viewer').classList.add('show-info');
  setTimeout(() => document.getElementById('viewer').classList.remove('show-info'), 2000);
  swipeUpCount = 0;
}

function closeViewer() {
  document.getElementById('viewer').classList.remove('active');
  document.getElementById('viewerImg').src = '';
  viewerIndex = -1;
}

async function showViewerImage() {
  if (viewerIndex < 0 || viewerIndex >= metaList.length) return;
  const m = metaList[viewerIndex];
  const el = document.getElementById('viewerImg');
  el.style.opacity = '0';

  // Load mid-res from DB
  try {
    const imgData = await dbGet('images', m.id);
    if (imgData && imgData.data) el.src = imgData.data;
    else {
      const th = await dbGet('thumbs', m.id);
      if (th) el.src = th.data;
    }
  } catch(e) {
    const th = await dbGet('thumbs', m.id);
    if (th) el.src = th.data;
  }

  el.onload = () => { el.style.opacity = '1'; };
  document.getElementById('viewerFilename').textContent = m.name;
  document.getElementById('viewerCounter').textContent = `${viewerIndex + 1} / ${metaList.length}`;
}

function viewerNav(dir) {
  const next = viewerIndex + dir;
  if (next < 0 || next >= metaList.length) return;
  const el = document.getElementById('viewerImg');
  el.style.transform = `translateX(${-dir * 30}px)`;
  el.style.opacity = '0';
  setTimeout(() => {
    viewerIndex = next;
    showViewerImage();
    el.style.transform = `translateX(${dir * 30}px)`;
    requestAnimationFrame(() => { el.style.transform = 'translateX(0)'; });
  }, 80);
}

// Viewer gestures
(function() {
  const v = document.getElementById('viewer');
  let sx, sy, moved;
  v.addEventListener('touchstart', e => { sx = e.touches[0].clientX; sy = e.touches[0].clientY; moved = false; }, { passive: true });
  v.addEventListener('touchmove', () => { moved = true; }, { passive: true });
  v.addEventListener('touchend', e => {
    if (!moved) {
      v.classList.add('show-info');
      setTimeout(() => v.classList.remove('show-info'), 2000);
      return;
    }
    const dx = e.changedTouches[0].clientX - sx;
    const dy = e.changedTouches[0].clientY - sy;
    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 50) {
      swipeUpCount = 0;
      viewerNav(dx < 0 ? 1 : -1);
    } else if (Math.abs(dy) > Math.abs(dx) && dy < -50) {
      swipeUpCount++;
      clearTimeout(swipeUpTimer);
      swipeUpTimer = setTimeout(() => swipeUpCount = 0, 800);
      if (swipeUpCount >= 2) { swipeUpCount = 0; closeViewer(); }
    } else {
      swipeUpCount = 0;
    }
  }, { passive: true });
})();

// ===== GRID SIZE =====
function setGridSize(s) {
  gridSize = s;
  document.querySelectorAll('.size-btn').forEach(b => b.classList.toggle('active', b.dataset.size === s));
  clearVisibleRows();
  computeGrid();
  renderVirtual();
}

function clearVisibleRows() {
  Object.values(visibleRows).forEach(r => r.remove());
  visibleRows = {};
}

// ===== MODALS =====
function closeModal(id) { document.getElementById(id).classList.remove('active'); }

document.querySelectorAll('.modal-overlay').forEach(el => {
  el.addEventListener('click', e => { if (e.target === el) el.classList.remove('active'); });
});

document.getElementById('newFolderInput').addEventListener('keydown', e => { if (e.key === 'Enter') createFolder(); });
document.getElementById('renameFolderInput').addEventListener('keydown', e => { if (e.key === 'Enter') renameFolder(); });

// ===== TOAST =====
function toast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2000);
}

// ===== UTIL =====
function esc(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

// Keyboard
document.addEventListener('keydown', e => {
  if (document.getElementById('viewer').classList.contains('active')) {
    if (e.key === 'ArrowRight') viewerNav(1);
    else if (e.key === 'ArrowLeft') viewerNav(-1);
    else if (e.key === 'Escape') closeViewer();
  }
});

// ===== START =====
init();
</script>
</body>
</html>
